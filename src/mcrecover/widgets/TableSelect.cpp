/***************************************************************************
 * GameCube Memory Card Recovery Program.                                  *
 * TableSelect.cpp: Directory/Block Table select widget.                   *
 *                                                                         *
 * Copyright (c) 2014-2016 by David Korth.                                 *
 *                                                                         *
 * This program is free software; you can redistribute it and/or modify it *
 * under the terms of the GNU General Public License as published by the   *
 * Free Software Foundation; either version 2 of the License, or (at your  *
 * option) any later version.                                              *
 *                                                                         *
 * This program is distributed in the hope that it will be useful, but     *
 * WITHOUT ANY WARRANTY; without even the implied warranty of              *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
 * GNU General Public License for more details.                            *
 *                                                                         *
 * You should have received a copy of the GNU General Public License along *
 * with this program; if not, write to the Free Software Foundation, Inc., *
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.           *
 ***************************************************************************/

#include "TableSelect.hpp"

#include "card/GcnCard.hpp"
#include "McRecoverQApplication.hpp"

// Qt includes.
#include <QtCore/QSignalMapper>
#include <QFrame>
#include <QGridLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QPushButton>

/** TableSelectPrivate **/

class TableSelectPrivate
{
	public:
		explicit TableSelectPrivate(TableSelect *q);
		~TableSelectPrivate();

	protected:
		TableSelect *const q_ptr;
		Q_DECLARE_PUBLIC(TableSelect)
	private:
		Q_DISABLE_COPY(TableSelectPrivate)

	public:
		struct Ui_TableSelect {
			QHBoxLayout *hboxMain;

			// Directory table.
			QFrame *fraDirTable;
			QGridLayout *gridDirTable;
			QLabel *lblDirImage;
			QVector<QPushButton*> btnDir;
			QVector<QLabel*> lblDirStatus;

			// Block table.
			QFrame *fraBlockTable;
			QGridLayout *gridBlockTable;
			QLabel *lblBlockImage;
			QVector<QPushButton*> btnBlock;
			QVector<QLabel*> lblBlockStatus;

			void setupUi(QWidget *TableSelect);
			void retranslateUi(QWidget *TableSelect);
		};
		Ui_TableSelect ui;

		GcnCard *card;

		// Icon size.
		static const int iconSz = 16;

	protected:
		/**
		 * Update the DAT/BAT widget count based on the active GcnCard.
		 */
		void updateWidgetCount(void);

		/**
		 * Update the Directory Table display.
		 */
		void updateDirTableDisplay(void);

		/**
		 * Update the Block Table display.
		 */
		void updateBlockTableDisplay(void);

	public:
		/**
		 * Update the widget display.
		 */
		void updateWidgetDisplay(void);

		// Signal mappers.
		QSignalMapper *mapperDirTable;
		QSignalMapper *mapperBlockTable;
};

TableSelectPrivate::TableSelectPrivate(TableSelect *q)
	: q_ptr(q)
	, card(nullptr)
	, mapperDirTable(new QSignalMapper(q))
	, mapperBlockTable(new QSignalMapper(q))
{
	// Connect the QSignalMapper slots.
	QObject::connect(mapperDirTable, SIGNAL(mapped(int)),
			 q, SLOT(setActiveDatIdx(int)));
	QObject::connect(mapperBlockTable, SIGNAL(mapped(int)),
			 q, SLOT(setActiveBatIdx(int)));

	// TODO: Handle the case where active tables are changed in
	// the card outside of TableSelect?
}

TableSelectPrivate::~TableSelectPrivate()
{ }

/**
 * Initialize the UI.
 * @param TableSelect TableSelect.
 */
void TableSelectPrivate::Ui_TableSelect::setupUi(QWidget *TableSelect)
{
	if (TableSelect->objectName().isEmpty())
		TableSelect->setObjectName(QLatin1String("TableSelect"));

	// Icon size. [TODO: Where to determine icon size?]
	const QSize qIconSz(TableSelectPrivate::iconSz, TableSelectPrivate::iconSz);

	hboxMain = new QHBoxLayout(TableSelect);
	hboxMain->setContentsMargins(0, 0, 0, 0);
	hboxMain->setObjectName(QLatin1String("hboxMain"));

	// Directory table selection.
	fraDirTable = new QFrame(TableSelect);
	fraDirTable->setObjectName(QLatin1String("fraDirTable"));
	fraDirTable->setFrameShape(QFrame::NoFrame);
	fraDirTable->setFrameShadow(QFrame::Plain);

	gridDirTable = new QGridLayout(fraDirTable);
	gridDirTable->setObjectName(QLatin1String("gridDirTable"));
	gridDirTable->setContentsMargins(0, 0, 0, 0);
	gridDirTable->setVerticalSpacing(0);

	lblDirImage = new QLabel(fraDirTable);
	lblDirImage->setObjectName(QLatin1String("lblDirImage"));
	gridDirTable->addWidget(lblDirImage, 0, 0, 1, 1);

	QIcon iconDirTable = McRecoverQApplication::StandardIcon(
		QStyle::SP_DirClosedIcon, nullptr, lblDirImage);
	lblDirImage->setPixmap(iconDirTable.pixmap(qIconSz));

	// NOTE: btnDir and lblDirStatus are dynamically
	// generated by updateWidgetCount().

	// Block table selection.
	fraBlockTable = new QFrame(TableSelect);
	fraBlockTable->setObjectName(QLatin1String("fraBlockTable"));
	fraBlockTable->setFrameShape(QFrame::NoFrame);
	fraBlockTable->setFrameShadow(QFrame::Plain);

	gridBlockTable = new QGridLayout(fraBlockTable);
	gridBlockTable->setObjectName(QLatin1String("gridBlockTable"));
	gridBlockTable->setContentsMargins(0, 0, 0, 0);
	gridBlockTable->setVerticalSpacing(0);

	lblBlockImage = new QLabel(fraBlockTable);
	lblBlockImage->setObjectName(QLatin1String("lblBlockImage"));
	gridBlockTable->addWidget(lblBlockImage, 0, 0, 1, 1);

	QIcon iconBlockTable;
#ifdef Q_OS_WIN
	// Win32: Get the icon from Windows Defragmenter.
	iconBlockTable = McRecoverQApplication::Win32Icon(
		McRecoverQApplication::W32ICON_DEFRAG, qIconSz);
	if (iconBlockTable.isNull())
#endif /* Q_OS_WIN */
	{
		iconBlockTable = McRecoverQApplication::IconFromTheme(
			QLatin1String("partitionmanager"));
	}
	lblBlockImage->setPixmap(iconBlockTable.pixmap(qIconSz));

	// NOTE: btnBlock and lblBlockStatus are dynamically
	// generated by updateWidgetCount().

	hboxMain->addWidget(fraDirTable);
	hboxMain->addWidget(fraBlockTable);

	retranslateUi(TableSelect);
}

/**
 * Initialize the UI.
 * @param TableSelect TableSelect.
 */
void TableSelectPrivate::Ui_TableSelect::retranslateUi(QWidget *TableSelect)
{
#ifndef QT_NO_TOOLTIP
        lblDirImage->setToolTip(TableSelect::tr("Directory Table"));
	lblBlockImage->setToolTip(TableSelect::tr("Block Table"));
#endif // QT_NO_TOOLTIP
        Q_UNUSED(TableSelect);
}

/**
 * Update the DAT/BAT widget count based on the active GcnCard.
 */
void TableSelectPrivate::updateWidgetCount(void)
{
	if (!card) {
		// No GcnCard.
		return;
	}

	QSizePolicy sizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
	const QSize btnSize(23, 23);

	// Check if we need to update Dir widgets.
	const int datCount = card->datCount();
	if (datCount < ui.btnDir.size()) {
		// Too many Dir widgets.
		// Remove unneeded ones.
		for (int i = ui.btnDir.size()-1; i >= datCount; i--) {
			delete ui.btnDir[i];
			delete ui.lblDirStatus[i];
		}
		ui.btnDir.resize(datCount);
		ui.lblDirStatus.resize(datCount);
	} else if (datCount > ui.btnDir.size()) {
		// Not enough Dir widgets.
		// Add new ones.
		ui.btnDir.reserve(datCount);
		ui.lblDirStatus.reserve(datCount);
		for (int i = ui.btnDir.size(); i < datCount; i++) {
			QPushButton *btn = new QPushButton(ui.fraDirTable);
			btn->setMinimumSize(btnSize);
			btn->setMaximumSize(btnSize);
			btn->setBaseSize(btnSize);
			btn->setText(QString(QChar(L'A' + i)));
			btn->setCheckable(true);
			btn->setAutoExclusive(true);
			sizePolicy.setHeightForWidth(btn);
			btn->setSizePolicy(sizePolicy);
			ui.gridDirTable->addWidget(btn, i, 1, 1, 1);
			ui.btnDir.append(btn);

			QLabel *lbl = new QLabel(ui.fraDirTable);
			ui.gridDirTable->addWidget(lbl, i, 2, 1, 1);
			ui.lblDirStatus.append(lbl);

			// Connect signals.
			QObject::connect(btn, SIGNAL(clicked()),
					 mapperDirTable, SLOT(map()));
			mapperDirTable->setMapping(btn, i);
		}
	}

	// Check if we need to update Block widgets.
	const int batCount = card->batCount();
	if (batCount < ui.btnDir.size()) {
		// Too many Block widgets.
		// Remove unneeded ones.
		for (int i = ui.btnBlock.size()-1; i >= batCount; i--) {
			delete ui.btnBlock[i];
			delete ui.lblBlockStatus[i];
		}
		ui.btnBlock.resize(batCount);
		ui.lblBlockStatus.resize(batCount);
	} else if (batCount > ui.btnBlock.size()) {
		// Not enough Block widgets.
		// Add new ones.
		ui.btnBlock.reserve(batCount);
		ui.lblBlockStatus.reserve(batCount);
		for (int i = ui.btnBlock.size(); i < batCount; i++) {
			QPushButton *btn = new QPushButton(ui.fraBlockTable);
			btn->setMinimumSize(btnSize);
			btn->setMaximumSize(btnSize);
			btn->setBaseSize(btnSize);
			btn->setText(QString(QChar(L'A' + i)));
			btn->setCheckable(true);
			btn->setAutoExclusive(true);
			sizePolicy.setHeightForWidth(btn);
			btn->setSizePolicy(sizePolicy);
			ui.gridBlockTable->addWidget(btn, i, 1, 1, 1);
			ui.btnBlock.append(btn);

			QLabel *lbl = new QLabel(ui.fraBlockTable);
			ui.gridBlockTable->addWidget(lbl, i, 2, 1, 1);
			ui.lblBlockStatus.append(lbl);

			// Connect signals.
			QObject::connect(btn, SIGNAL(clicked()),
					 mapperBlockTable, SLOT(map()));
			mapperBlockTable->setMapping(btn, i);
		}
	}
}

/**
 * Update the Directory Table display.
 */
void TableSelectPrivate::updateDirTableDisplay(void)
{
	// Active table CSS.
	// Used to indicate which table is active according to the card header.
	// TODO: Use a better indicator.
	const QString cssActiveHdr =
		QLatin1String("QFrame { border: 2px solid rgb(0,255,0); }");
	const QString cssInactiveHdr =
		QLatin1String("QFrame { margin: 2px; }");

	// Check which table is currently active, selected by the user.
	const int activeDatIdx = card->activeDatIdx();
	if (activeDatIdx >= 0 && activeDatIdx < ui.btnDir.count()) {
		ui.btnDir[activeDatIdx]->setChecked(true);
	} else {
		// No active table.
		foreach (QPushButton *btn, ui.btnDir) {
			btn->setChecked(false);
		}
	}

	// Icon size. [TODO: Where to determine icon size?]
	const QSize qIconSz(iconSz, iconSz);

	// Check which tables are active and valid,
	// according to the card header.
	const int activeDatHdrIdx = card->activeDatHdrIdx();
	for (int i = ui.lblDirStatus.size()-1; i >= 0; i--) {
		QLabel *const lbl = ui.lblDirStatus[i];
		if (i == activeDatHdrIdx) {
			lbl->setStyleSheet(cssActiveHdr);
		} else {
			lbl->setStyleSheet(cssInactiveHdr);
		}

		const bool isDatValid = card->isDatValid(i);
		QStyle::StandardPixmap sp = (isDatValid
					? QStyle::SP_DialogApplyButton
					: QStyle::SP_MessageBoxCritical);
		QIcon icon = McRecoverQApplication::StandardIcon(sp, nullptr, lbl);
		lbl->setPixmap(icon.pixmap(qIconSz));

#ifndef QT_NO_TOOLTIP
		// Set the status tooltip.
		QString tip;
		if (isDatValid) {
			if (i == activeDatHdrIdx) {
				//: %1 == "Block Table" or "Directory Table"; %2 == table ID ('A', 'B', etc.)
				tip = TableSelect::tr("%1 %2 is valid, and is the active table on the card.");
			} else {
				//: %1 == "Block Table" or "Directory Table"; %2 == table ID ('A', 'B', etc.)
				tip = TableSelect::tr("%1 %2 is valid.");
			}
		} else {
			//: %1 == "Block Table" or "Directory Table"; %2 == table ID ('A', 'B', etc.)
			tip = TableSelect::tr("%1 %2 is invalid.");
		}

		lbl->setToolTip(tip
			.arg(TableSelect::tr("Directory Table"))
			.arg(QChar(L'A' + i)));
#endif /* QT_NO_TOOLTIP */
	}
}

/**
 * Update the Block Table display.
 */
void TableSelectPrivate::updateBlockTableDisplay(void)
{
	// Active table CSS.
	// Used to indicate which table is active according to the card header.
	// TODO: Use a better indicator.
	const QString cssActiveHdr =
		QLatin1String("QFrame { border: 2px solid rgb(0,255,0); }");
	const QString cssInactiveHdr =
		QLatin1String("QFrame { margin: 2px; }");

	// Check which table is currently active, selected by the user.
	const int activeBatIdx = card->activeBatIdx();
	if (activeBatIdx >= 0 && activeBatIdx < ui.btnBlock.count()) {
		ui.btnBlock[activeBatIdx]->setChecked(true);
	} else {
		// No active table.
		foreach (QPushButton *btn, ui.btnBlock) {
			btn->setChecked(false);
		}
	}

	// Icon size. [TODO: Where to determine icon size?]
	const QSize qIconSz(iconSz, iconSz);

	// Check which tables are active and valid,
	// according to the card header.
	const int activeBatHdrIdx = card->activeBatHdrIdx();
	for (int i = ui.lblBlockStatus.size()-1; i >= 0; i--) {
		QLabel *const lbl = ui.lblBlockStatus[i];
		if (i == activeBatHdrIdx) {
			lbl->setStyleSheet(cssActiveHdr);
		} else {
			lbl->setStyleSheet(cssInactiveHdr);
		}

		const bool isBatValid = card->isBatValid(i);
		QStyle::StandardPixmap sp = (isBatValid
					? QStyle::SP_DialogApplyButton
					: QStyle::SP_MessageBoxCritical);
		QIcon icon = McRecoverQApplication::StandardIcon(sp, nullptr, lbl);
		lbl->setPixmap(icon.pixmap(qIconSz));

#ifndef QT_NO_TOOLTIP
		// Set the status tooltip.
		QString tip;
		if (isBatValid) {
			if (i == activeBatHdrIdx) {
				//: %1 == "Block Table" or "Directory Table"; %2 == table ID ('A', 'B', etc.)
				tip = TableSelect::tr("%1 %2 is valid, and is the active table on the card.");
			} else {
				//: %1 == "Block Table" or "Directory Table"; %2 == table ID ('A', 'B', etc.)
				tip = TableSelect::tr("%1 %2 is valid.");
			}
		} else {
			//: %1 == "Block Table" or "Directory Table"; %2 == table ID ('A', 'B', etc.)
			tip = TableSelect::tr("%1 %2 is invalid.");
		}

		lbl->setToolTip(tip
			.arg(TableSelect::tr("Block Table"))
			.arg(QChar(L'A' + i)));
#endif /* QT_NO_TOOLTIP */
	}
}

/**
 * Update the widget display.
 */
void TableSelectPrivate::updateWidgetDisplay(void)
{
	if (!card) {
		// Hide the widget display.
		// TODO: Better method?
		ui.fraDirTable->setVisible(false);
		ui.fraBlockTable->setVisible(false);
		return;
	}

	// Update the widget count.
	updateWidgetCount();

	// Update the table displays.
	// TODO: Consolidate the two functions?
	updateDirTableDisplay();
	updateBlockTableDisplay();

	// Show the widgets.
	ui.fraDirTable->setVisible(true);
	ui.fraBlockTable->setVisible(true);
}

/** TableSelect **/

TableSelect::TableSelect(QWidget *parent)
	: super(parent)
	, d_ptr(new TableSelectPrivate(this))
{
	Q_D(TableSelect);
	d->ui.setupUi(this);
}

TableSelect::~TableSelect()
{
	Q_D(TableSelect);
	delete d;
}

/**
 * Get the GcnCard being displayed.
 * @return GcnCard.
 */
GcnCard *TableSelect::card(void) const
{
	Q_D(const TableSelect);
	return d->card;
}

/**
 * Set the GcnCard being displayed.
 * @param card GcnCard.
 */
void TableSelect::setCard(GcnCard *card)
{
	Q_D(TableSelect);

	// Disconnect the GcnCard's destroyed() signal if a GcnCard is already set.
	if (d->card) {
		disconnect(d->card, SIGNAL(destroyed(QObject*)),
			   this, SLOT(memCard_destroyed_slot(QObject*)));
	}

	d->card = card;

	// Connect the GcnCard's destroyed() signal.
	if (d->card) {
		connect(d->card, SIGNAL(destroyed(QObject*)),
			this, SLOT(memCard_destroyed_slot(QObject*)));
	}

	// Update the widget display.
	d->updateWidgetDisplay();
}

/** Events. **/

/**
 * Widget state has changed.
 * @param event State change event.
 */
void TableSelect::changeEvent(QEvent *event)
{
	if (event->type() == QEvent::LanguageChange) {
		// Retranslate the UI.
		Q_D(TableSelect);
		d->ui.retranslateUi(this);
		d->updateWidgetDisplay();
	}

	// Pass the event to the base class.
	super::changeEvent(event);
}

/** Properties. **/

/**
 * Get the selected directory table.
 * @return Selected directory table index, or -1 on error.
 */
int TableSelect::activeDatIdx(void) const
{
	Q_D(const TableSelect);
	if (!d->card)
		return -1;
	return d->card->activeDatIdx();
}

/**
 * Get the selected block table.
 * @return Selected block table index, or -1 on error.
 */
int TableSelect::activeBatIdx(void) const
{
	Q_D(const TableSelect);
	if (!d->card)
		return -1;
	return d->card->activeBatIdx();
}

/** Internal slots. **/

/**
 * GcnCard object was destroyed.
 * @param obj QObject that was destroyed.
 */
void TableSelect::memCard_destroyed_slot(QObject *obj)
{
	Q_D(TableSelect);

	if (obj == d->card) {
		// Our GcnCard was destroyed.
		d->card = nullptr;

		// Update the widget display.
		d->updateWidgetDisplay();
	}
}

/** Public slots. **/

/**
 * Set the active Directory Table index.
 * NOTE: This function reloads the file list, without lost files.
 * @param idx Active Directory Table index. (0 or 1)
 */
void TableSelect::setActiveDatIdx(int idx)
{
	Q_D(TableSelect);
	if (!d->card || idx < 0 || idx >= 2)
		return;
	d->card->setActiveDatIdx(idx);
}

/**
 * Set the active Block Table index.
 * NOTE: This function reloads the file list, without lost files.
 * @param idx Active Block Table index. (0 or 1)
 */
void TableSelect::setActiveBatIdx(int idx)
{
	Q_D(TableSelect);
	if (!d->card || idx < 0 || idx >= 2)
		return;
	d->card->setActiveBatIdx(idx);
}
